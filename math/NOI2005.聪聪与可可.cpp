/*
时间限制：1 s   内存限制：256 MB

【问题描述】

在一个魔法森林里，住着一只聪明的小聪聪聪聪和一只可爱的小可可可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只聪聪，
而可可终究是一只可可，同样不变的是，聪聪成天想着要吃掉可可。一天，聪聪意外得到了一台非常有用的机器，据说是叫GPS，
对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备 马上出发，去找可可。而可怜的可可还不
知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪， 
拯救可可，可她不知道还有没有足够的时间。

整个森林可以认为是一个无向图，图中有N个美丽的景点，景点从1至N编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。
当聪聪得到GPS时，可可正在景点M(M≤N)处。以后的每个时间单位，可可都会选择去相邻的景点(可能有多个)中的一个或停留在原景
点不 动。而去这些地方所发生的概率是相等的。假设有P个景点与景点M相邻，它们分别是景点R、景点S，……景点Q，在时刻T可可处
在景点M，则在(T＋1)时 刻，可可有1/(P+1)的可能在景点R，有1/(P+1)的可能在景点S，……，有1/(P+1)的可能在景点Q，还
有1/(P+1)的可能停在景点 M。

我们知道，聪聪是很聪明的，所以，当她在景点C时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最
小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。

在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。灰姑娘想
知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。

【输入文件】
从文件中读入数据。
数据的第1行为两个整数N和E，以空格分隔，分别表示森林中的景点数和连接相邻景点的路的条数。
第2行包含两个整数C和M，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。
接下来E行，每行两个整数，第i+2行的两个整数Ai和Bi表示景点Ai和景点Bi之间有一条路。
所有的路都是无向的，即：如果能从A走到B，就可以从B走到A。
输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。

【输出文件】
输出到文件中。
输出1个实数，四舍五入保留三位小数，表示平均多少个时间单位后聪聪会把可可吃掉。


【样例输入1】
4 3
1 4
1 2
2 3
3 4

【样例输出1】
1.500

【样例说明1】
开始时，聪聪和可可分别在景点1和景点4。
第一个时刻，聪聪先走，她向更靠近可可(景点4)的景点走动，走到景点2，然后走到景点3；假定忽略走路所花时间。
可可后走，有两种可能：
第一种是走到景点3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为1，概率为 0.5。 第二种是停在景点4，
不被吃掉。概率为 0.5。
到第二个时刻，聪聪向更靠近可可(景点4)的景点走动，只需要走一步即和可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。
所以平均的步数是1* 0.5+2* 0.5=1.5步。

【样例输入2】
9 9
9 3
1 2
2 3
3 4
4 5
3 6
4 6
4 7
7 8
8 9

【样例输出2】
2.167

【数据范围】
对于所有的数据，1≤N,E≤980。
对于50%的数据，1≤N≤50。

解题思路:
如果聪聪和可可的位置分别是i和j，i的邻点离可可最近的位置是c(i,j)，则聪聪的下一个位置是c(c(i,j),j), 可可
的下一个位置是集合w(j)=(j1,j2,..,jd),每个位置的概率为1/d。如果 f(i,j)是聪聪抓到可可的平均时间，
f(i,j) = Sum( f(c(c(i,j),j), jk) )/d + 1. (k=1...d)

f(i,i) = 0; //聪聪和可可在同一个位置.
如果c(i,j) = j, 或者 c(c(i,j),j)=j, 则 f(i,j) = 1, 也就是聪聪只需要走一步或者两步就可以抓到可可.
*/

#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
const int maxn = 1e3;

vector<int> g[maxn];
int c[maxn][maxn];
double f[maxn][maxn];
bool vis[maxn];

void BFS(int s)
{
    memset(vis, 0 ,sizeof(vis));
    queue<int> q;
    q.push(s);
    vis[s] = 1;
    while(!q.empty())
    {
        int u = q.front(); q.pop();
        for(int i=0,n=g[u].size(); i<n; ++i)
        {
            int v = g[u][i];
            if(!vis[v])
            {
                c[s][v] = u; //从v到s点最近的路径上下一步是结点u
                vis[v] = 1;
                q.push(v);
            }
        }
    }
}

//
double F(int cc,int kk)
{
    // printf("F(%d, %d)=\n", cc, kk );
    int next1 = c[kk][cc];
    int next2 = c[kk][next1];
    if(cc == kk) return 0;
    if(next1 == kk || next2 == kk) return f[cc][kk] = 1;
    if(f[cc][kk] > 0) return f[cc][kk];

    double Ex = 0;
    int d = g[kk].size();
    for(int k=0; k<d; ++k)
    {
        int jk = g[kk][k];
        Ex += F( next2, jk); //聪聪走两步, 可可走一步
    }
    Ex += F(next2, kk); //聪聪走两步, 可可不走
    Ex /= (d+1); //可可走一步有d种, 可可不走有1种, 一共d+1种选择
    Ex += 1;  //每走一次花费1个单位时间

    // printf("F(%d, %d)=%lf\n", cc, kk ,Ex);
    return f[cc][kk] = Ex;
}


int main()
{
    #ifdef WFX
    freopen("in.txt","r",stdin);
    #endif

    int N, E, cc, kk; //cc表示聪聪的位置, kk表示可可的位置
    scanf("%d%d%d%d", &N, &E, &cc, &kk);
    for(int i=0, u, v; i<E; ++i)
    {
        scanf("%d%d", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
    }

    //计算c[i][j]
    for(int i=1; i<=N; ++i) BFS(i);
    
    printf("%.3lf\n", F(cc, kk));

    return 0;
}